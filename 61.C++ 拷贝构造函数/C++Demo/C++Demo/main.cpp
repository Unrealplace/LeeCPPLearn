//
//  main.cpp
//  C++Demo
//
//  Created by LiYang on 2017/6/4.
//  Copyright © 2017年 LiYang. All rights reserved.
//

#include <iostream>
#include <string>
#include "ObjectClass.hpp"

using namespace std;

void func(string str){

    cout << str << endl;
    
}
int main(int argc, const char * argv[]) {
  
    
    cout << *argv << endl;
    
    string s1 = "hello everyone...";
    string s2(s1);
    string s3 = s1;
    string s4 = s1 + "  " + s2;
    func(s1);
    cout<<s1<<endl<<s2<<endl<<s3<<endl<<s4<<endl;

//    s1、s2、s3、s4 以及 func() 的形参 str，都是使用拷贝的方式来初始化的。
//    对于 s1，表面上看起来是将一个字符串直接赋值给了 s1，实际上在内部进行了类型转换，将 const char * 类型转换为 string 类型后才赋值的，这点我们将在《C++转换构造函数》一节中详细讲解。s4 也是类似的道理。
//    对于 s1、s2、s3、s4，都是将其它对象的数据拷贝给当前对象，以完成当前对象的初始化。
//    
//    对于 func() 的形参 str，其实在定义时就为它分配了内存，但是此时并没有初始化，只有等到调用 func() 时，才会将其它对象的数据拷贝给 str 以完成初始化。
//    
//    当以拷贝的方式初始化一个对象时，会调用一个特殊的构造函数，就是拷贝构造函数（Copy Constructor）。
//
    cout << "************************************"<<endl;
    Student stu1("oliver",23,2324);
    Student stu2 = stu1; //调用拷贝构造函数
    Student stu3(stu1);//调用拷贝构造函数
    stu1.display();
    stu2.display();
    stu3.display();
    
//    1) 为什么必须是当前类的引用呢？
//    
//    如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。
//    
//    只有当参数是当前类的引用时，才不会导致再次调用拷贝构造函数，这不仅是逻辑上的要求，也是 C++ 语法的要求。
//    2) 为什么是 const 引用呢？
//    
//    拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据，添加 const 限制后，这个含义更加明确了。
//    
//    另外一个原因是，添加 const 限制后，可以将 const 对象和非 const 对象传递给形参了，因为非 const 类型可以转换为 const 类型。如果没有 const 限制，就不能将 const 对象传递给形参，因为 const 类型不能转换为非 const 类型，这就意味着，不能使用 const 对象来初始化当前对象了。

    
//    默认拷贝构造函数
//    
//    在前面的教程中，我们还没有讲解拷贝构造函数，但是却已经在使用拷贝的方式创建对象了，并且也没有引发什么错误。这是因为，如果程序员没有显式地定义拷贝构造函数，那么编译器会自动生成一个默认的拷贝构造函数。这个默认的拷贝构造函数很简单，就是使用“老对象”的成员变量对“新对象”的成员变量进行一一赋值，和上面 Student 类的拷贝构造函数非常类似。
//    
//    对于简单的类，默认拷贝构造函数一般是够用的，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认拷贝构造函数就不能拷贝这些资源，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据，这点我们将在《C++深拷贝和浅拷贝》一节中深入讲解。
    
    
    
    return 0;
}
