//
//  main.cpp
//  C++Demo
//
//  Created by MacBook on 2017/5/9.
//  Copyright © 2017年 Oliver. All rights reserved.
//

#include <iostream>
//#include "ObjectClass.hpp"
#include "ObjectClass1.hpp"

int main(int argc, const char * argv[]) {
    
   ///*************************************////
//    A a(10);
//    B b(66, 99);
//    //赋值前
//    a.display();
//    b.display();
//    cout<<"--------------"<<endl;
//    //赋值后
//    a = b;
//    a.display();
//    b.display();
   ///*************************************////


//    Class A: m_a=10
//    Class B: m_a=66, m_b=99
//    --------------
//    Class A: m_a=66
//    Class B: m_a=66, m_b=99
    
    
//    本例中 A 是基类， B 是派生类，a、b 分别是它们的对象，由于派生类 B 包含了从基类 A 继承来的成员，因此可以将派生类对象 b 赋值给基类对象 a。通过运行结果也可以发现，赋值后 a 所包含的成员变量的值已经发生了变化。
//    
//    赋值的本质是将现有的数据写入已分配好的内存中，对象的内存只包含了成员变量，所以对象之间的赋值是成员变量的赋值，成员函数不存在赋值问题。运行结果也有力地证明了这一点，虽然有a=b;这样的赋值过程，但是 a.display() 始终调用的都是 A 类的 display() 函数。换句话说，对象之间的赋值不会影响成员函数，也不会影响 this 指针
//     将派生类对象赋值给基类对象时，会舍弃派生类新增的成员，也就是“大材小用”，如下图所示： 
    
    
//    可以发现，即使将派生类对象赋值给基类对象，基类对象也不会包含派生类的成员，所以依然不同通过基类对象来访问派生类的成员。对于上面的例子，a.m_a 是正确的，但 a.m_b 就是错误的，因为 a 不包含成员 m_b。
//    
//    这种转换关系是不可逆的，只能用派生类对象给基类对象赋值，而不能用基类对象给派生类对象赋值。理由很简单，基类不包含派生类的成员变量，无法对派生类的成员变量赋值。同理，同一基类的不同派生类对象之间也不能赋值。
//    
//    要理解这个问题，还得从赋值的本质入手。赋值实际上是向内存填充数据，当数据较多时很好处理，舍弃即可；本例中将 b 赋值给 a 时（执行a=b;语句），成员 m_b 是多余的，会被直接丢掉，所以不会发生赋值错误。但当数据较少时，问题就很棘手，编译器不知道如何填充剩下的内存；如果本例中有b= a;这样的语句，编译器就不知道该如何给变量 m_b 赋值，所以会发生错误。
    
    
    
//    也就是说，将派生类指针赋值给基类指针时，通过基类指针只能使用派生类的成员变量，但不能使用派生类的成员函数，这看起来有点不伦不类，究竟是为什么呢？
    
//    pa 本来是基类 A 的指针，现在指向了派生类 D 的对象，这使得隐式指针 this 发生了变化，也指向了 D 类的对象，所以最终在 display() 内部使用的是 D 类对象的成员变量，相信这一点不难理解
    
    
    // 懵逼。。。。。
//    编译器虽然通过指针的指向来访问成员变量，但是却不通过指针的指向来访问成员函数：编译器通过指针的类型来访问成员函数。对于 pa，它的类型是 A，不管它指向哪个对象，使用的都是 A 类的成员函数，具体原因已在《C++函数编译原理和成员函数的实现》中做了详细讲解。
//    
//    概括起来说就是：编译器通过指针来访问成员变量，指针指向哪个对象就使用哪个对象的数据；编译器通过指针的类型来访问成员函数，指针属于哪个类的类型就使用哪个类的函数。
    
    A *pa = new A(1);
    B *pb = new B(2, 20);
    C *pc = new C(3);
    D *pd = new D(4, 40, 400, 4000);
    pa = pd;
    pa -> display();
    pb = pd;
    pb -> display();
    pc = pd;
    pc -> display();  //调用子类的变量，调用父类的成员函数
    cout<<"-----------------------"<<endl;
    cout<<"pa="<<pa<<endl;
    cout<<"pb="<<pb<<endl;
    cout<<"pc="<<pc<<endl;
    cout<<"pd="<<pd<<endl;
    
    
//    Class A: m_a=4
//    Class B: m_a=4, m_b=40
//    Class C: m_c=400
//    -----------------------
//    pa=0x100401040
//    pb=0x100401040
//    pc=0x100401048
//    pd=0x100401040
    
//    将派生类引用赋值给基类引用
//    
//    引用在本质上是通过指针的方式实现的，这一点已在《引用在本质上是什么，它和指针到底有什么区别》中进行了讲解，既然基类的指针可以指向派生类的对象，那么我们就有理由推断：基类的引用也可以指向派生类的对象，并且它的表现和指针是类似的。
    
    cout<<"-----------------------"<<endl;

    D d(4,25,400,4000);
    
    A &ra = d;
    B &rb = d;
    C &rc = d;
    
    ra.display();
    rb.display();
    rc.display();
//    
//    -----------------------˜
//    Class A: m_a=4
//    Class B: m_a=4, m_b=25
//    Class C: m_c=400
//    ra、rb、rc 是基类的引用，它们都引用了派生类对象 d，并调用了 display() 函数，从运行结果可以发现，虽然使用了派生类对象的成员变量，但是却没有使用派生类的成员函数，这和指针的表现是一样的。

    
    
    
    
    
    return 0;
}
