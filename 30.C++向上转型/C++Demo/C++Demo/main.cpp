//
//  main.cpp
//  C++Demo
//
//  Created by MacBook on 2017/5/9.
//  Copyright © 2017年 Oliver. All rights reserved.
//

#include <iostream>
//#include "ObjectClass.hpp"
#include "ObjectClass1.hpp"

int main(int argc, const char * argv[]) {
    
   ///*************************************////
//    A a(10);
//    B b(66, 99);
//    //赋值前
//    a.display();
//    b.display();
//    cout<<"--------------"<<endl;
//    //赋值后
//    a = b;
//    a.display();
//    b.display();
   ///*************************************////


//    Class A: m_a=10
//    Class B: m_a=66, m_b=99
//    --------------
//    Class A: m_a=66
//    Class B: m_a=66, m_b=99
    
    
//    本例中 A 是基类， B 是派生类，a、b 分别是它们的对象，由于派生类 B 包含了从基类 A 继承来的成员，因此可以将派生类对象 b 赋值给基类对象 a。通过运行结果也可以发现，赋值后 a 所包含的成员变量的值已经发生了变化。
//    
//    赋值的本质是将现有的数据写入已分配好的内存中，对象的内存只包含了成员变量，所以对象之间的赋值是成员变量的赋值，成员函数不存在赋值问题。运行结果也有力地证明了这一点，虽然有a=b;这样的赋值过程，但是 a.display() 始终调用的都是 A 类的 display() 函数。换句话说，对象之间的赋值不会影响成员函数，也不会影响 this 指针
//     将派生类对象赋值给基类对象时，会舍弃派生类新增的成员，也就是“大材小用”，如下图所示： 
    
    
//    可以发现，即使将派生类对象赋值给基类对象，基类对象也不会包含派生类的成员，所以依然不同通过基类对象来访问派生类的成员。对于上面的例子，a.m_a 是正确的，但 a.m_b 就是错误的，因为 a 不包含成员 m_b。
//    
//    这种转换关系是不可逆的，只能用派生类对象给基类对象赋值，而不能用基类对象给派生类对象赋值。理由很简单，基类不包含派生类的成员变量，无法对派生类的成员变量赋值。同理，同一基类的不同派生类对象之间也不能赋值。
//    
//    要理解这个问题，还得从赋值的本质入手。赋值实际上是向内存填充数据，当数据较多时很好处理，舍弃即可；本例中将 b 赋值给 a 时（执行a=b;语句），成员 m_b 是多余的，会被直接丢掉，所以不会发生赋值错误。但当数据较少时，问题就很棘手，编译器不知道如何填充剩下的内存；如果本例中有b= a;这样的语句，编译器就不知道该如何给变量 m_b 赋值，所以会发生错误。
    
    
    
    A *pa = new A(1);
    B *pb = new B(2, 20);
    C *pc = new C(3);
    D *pd = new D(4, 40, 400, 4000);
    pa = pd;
    pa -> display();
    pb = pd;
    pb -> display();
    pc = pd;
    pc -> display();
    cout<<"-----------------------"<<endl;
    cout<<"pa="<<pa<<endl;
    cout<<"pb="<<pb<<endl;
    cout<<"pc="<<pc<<endl;
    cout<<"pd="<<pd<<endl;
    
//    Class A: m_a=4
//    Class B: m_a=4, m_b=40
//    Class C: m_c=400
//    -----------------------
//    pa=0x100401040
//    pb=0x100401040
//    pc=0x100401048
//    pd=0x100401040
    
    
    
    
    
    return 0;
}
